---
title: "Adding a GitHub Contribution Graph to Next.js"
slug: "adding-github-contribution-graph-to-nextjs"
excerpt: "How to add a GitHub contribution graph via GraphQL and HTML scraping fallbacks, with caching and hydration fixes in Next.js."
publishedAt: "2025-04-02"
updatedAt: "2025-04-02"
author: "william-callahan"
tags: ["nextjs", "github", "graphql", "api", "react", "typescript", "scraping", "caching"]
coverImage: "/images/posts/github-commit-graphic-history.png"
readingTime: 4 # Adjusted reading time
---

This is a quick guide on how I added a GitHub contribution graph to my site. It requires handling API access and potential fallbacks. GitHub doesn't offer a simple embed, so a custom solution is needed. This implementation uses the GitHub GraphQL API as the primary data source, falling back to HTML scraping if the API fails or is unavailable.

## GraphQL API for Contribution Data

The primary method involves querying GitHub's GraphQL endpoint, requiring a personal access token (stored as `GITHUB_ACCESS_TOKEN_COMMIT_GRAPH`) with permission to read user contribution data.

The query retrieves the contribution calendar for a specific date range:

```typescript
const GITHUB_USERNAME = 'github-username';
const GITHUB_API_TOKEN = process.env.GITHUB_ACCESS_TOKEN_COMMIT_GRAPH;
const { user } = await graphql<GitHubGraphQLContributionResponse>(`
  query($username: String!, $from: DateTime!, $to: DateTime!) {
    user(login: $username) {
      contributionsCollection(from: $from, to: $to) {
        contributionCalendar {
          weeks {
            contributionDays {
              contributionCount
              contributionLevel # e.g., NONE, FIRST_QUARTILE
              date
            }
          }
          totalContributions
        }
      }
    }
  }
`, {
  username: GITHUB_USERNAME,
  from: fromDate + 'T00:00:00Z',
  to: toDate + 'T23:59:59Z',
  headers: {
    authorization: `bearer ${GITHUB_API_TOKEN}`,
  },
});

// Flatten and transform the nested response data
const contributionDays = user.contributionsCollection.contributionCalendar.weeks.flatMap(
  week => week.contributionDays
);

// Map string levels to numeric values for rendering
const mapContributionLevel = (level: string): number => {
  switch (level) {
    case 'NONE': return 0;
    case 'FIRST_QUARTILE': return 1;
    case 'SECOND_QUARTILE': return 2;
    case 'THIRD_QUARTILE': return 3;
    case 'FOURTH_QUARTILE': return 4;
    default: return 0;
  }
};

const contributions: ContributionDay[] = contributionDays.map(day => ({
  date: day.date,
  count: day.contributionCount,
  level: mapContributionLevel(day.contributionLevel),
}));

```

## HTML Scraping Fallback

If the GraphQL query fails, the system falls back to scraping the public GitHub profile page using `node-fetch` and `cheerio`. This extracts data directly from the SVG contribution graph elements.

```typescript
import * as cheerio from 'cheerio';
import fetch from 'node-fetch'; // or use native fetch if available

async function fetchActivityByScraping(): Promise<GitHubActivityApiResponse> {
  const profileUrl = `https://github.com/${GITHUB_USERNAME}`;
  const response = await fetch(profileUrl, { /* ... headers ... */ });
  const html = await response.text();
  const $ = cheerio.load(html);

  const contributions: ContributionDay[] = [];
  // Selector targets the <rect> elements within the graph SVG
  const dailyRectSelector = 'svg.js-calendar-graph-svg g > g > rect[data-date][data-level]';

  $(dailyRectSelector).each((_, element) => {
    const $rect = $(element);
    const date = $rect.attr('data-date');
    const levelAttr = $rect.attr('data-level');
    const level = levelAttr ? parseInt(levelAttr, 10) : 0;

    // Contribution count requires parsing the associated tooltip text
    let count = 0;
    const tooltipId = $rect.attr('id');
    // Find the tooltip element linked by the 'for' attribute
    let tooltipText = tooltipId ? $(`tool-tip[for="${tooltipId}"]`).text().trim() : '';
    const countMatch = tooltipText.match(/^(\d+|No)\s+contribution/);
    if (countMatch) {
      count = countMatch[1] === 'No' ? 0 : parseInt(countMatch[1], 10);
    }

    if (date && !isNaN(level)) {
      contributions.push({ date, count: isNaN(count) ? 0 : count, level });
    }
  });

  // Extract total contributions from the header text
  const totalCountSelector = 'div.js-yearly-contributions h2';
  const totalContributionsHeader = $(totalCountSelector).text().trim();
  let totalContributionsText = '0'; // Default to '0'
  const totalMatch = totalContributionsHeader.match(/([\d,]+)\s+contributions/i);
  if (totalMatch && totalMatch[1]) {
    totalContributionsText = totalMatch[1].replace(/,/g, '');
  }

  return {
    source: 'scraping',
    data: contributions,
    totalContributions: totalContributionsText
  };
}
```
*Note: Scraping is inherently fragile and may break if GitHub changes its page structure.*

## Caching Strategy

To minimize external requests, fetched data (whether from API or scraping) is cached server-side using an in-memory cache (`node-cache` or similar) with a 24-hour TTL. Manual cache invalidation is supported via a `?refresh=true` query parameter on the API endpoint serving this data.

```typescript
// Example API route logic
import cache from '@/lib/cache'; // Assuming a simple cache instance

const GITHUB_ACTIVITY_CACHE_KEY = 'github_activity_data';
const CACHE_TTL_DAILY = 24 * 60 * 60; // 24 hours in seconds

export async function GET(request: Request) {
  const url = new URL(request.url);
  const refreshCache = url.searchParams.get('refresh') === 'true';

  if (refreshCache) {
    cache.del(GITHUB_ACTIVITY_CACHE_KEY);
  }

  const cachedData = cache.get<GitHubActivityApiResponse>(GITHUB_ACTIVITY_CACHE_KEY);
  if (cachedData && !refreshCache) {
    return NextResponse.json(cachedData);
  }

  let activityData: GitHubActivityApiResponse;
  try {
    // Attempt GraphQL fetch
    activityData = await fetchActivityFromGraphQL();
  } catch (error) {
    console.warn('GraphQL fetch failed, falling back to scraping:', error);
    // Attempt scraping fetch
    activityData = await fetchActivityByScraping();
  }

  // Store fetched data in cache
  cache.set(GITHUB_ACTIVITY_CACHE_KEY, activityData, CACHE_TTL_DAILY);

  return NextResponse.json(activityData);
}
```

## Rendering the Graph

The fetched `contributions` array is rendered as a grid, mimicking the GitHub style. Tailwind CSS classes map contribution levels to background colors, including dark mode variants.

```tsx
// Simplified rendering component excerpt
const getLevelColor = (level: number): string => {
  // Map level (0-4) to Tailwind background color classes
  // (e.g., bg-gray-100 dark:bg-gray-800 for level 0,
  //  bg-green-200 dark:bg-green-900 for level 1, etc.)
  switch (level) {
    case 0: return 'bg-gray-100 dark:bg-gray-800';
    case 1: return 'bg-green-200 dark:bg-green-900';
    case 2: return 'bg-green-400 dark:bg-green-700';
    case 3: return 'bg-green-600 dark:bg-green-500';
    case 4: return 'bg-green-800 dark:bg-green-300';
    default: return 'bg-gray-100 dark:bg-gray-800';
  }
};

function ContributionGraph({ data }: { data: ContributionDay[] }) {
  return (
    <div className="grid grid-flow-col grid-rows-7 gap-1 p-2 overflow-x-auto">
      {data.map((day) => (
        <div
          key={day.date}
          className={`w-3 h-3 rounded-sm ${getLevelColor(day.level)}`}
          title={`${day.count} contributions on ${day.date}`}
        />
      ))}
    </div>
  );
}
```

## Fixing Hydration Errors from Nested Links

A common issue when making complex components clickable is invalid HTML nesting, such as `<a>` tags within `<a>` tags, which leads to React hydration errors.

**Incorrect (causes hydration error):**
```jsx
<a href="URL">
  <div> {isLoading ? <a href="URL">Loading...</a> : content } </div>
</a>
```

**Correct (using clickable div):**
```jsx
const navigateToUrl= () => window.open(URL, '_blank', 'noopener,noreferrer');

<div
  onClick={navigateToUrl}
  className="cursor-pointer"
  role="button" // Accessibility
  tabIndex={0}  // Accessibility
  onKeyDown={(e) => e.key === 'Enter' && navigateToUrl()} // Accessibility
>
  {isLoading ? <span>Loading...</span> : content }
</div>
```
Using a `div` with an `onClick` handler, `role="button"`, `tabIndex="0"`, and an `onKeyDown` handler for keyboard accessibility provides the same user experience without causing hydration errors.