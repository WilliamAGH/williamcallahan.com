---
title: "Attempting to Design a Back-end with Cleaner Architecture Rules and Boundaries"
slug: "attempting-cleaner-architecture-boundaries-backend-refactor"
excerpt: "How I'm learning to keep cleaner architectural boundaries (while 'moving fast and breaking things')."
publishedAt: "2025-11-07"
updatedAt: "2025-11-07"
author: "william-callahan"
tags:
  [
    "backend",
    "architecture",
    "spring boot",
    "clean architecture",
    "refactoring",
    "java",
    "api design",
    "boundaries"
  ]
coverImage: "/images/posts/clean-software-architecture-boundaries.png"
---

I've been writing code with hygiene and type safety in mind for a while now (or at least trying to). Every function gets explicit return types, objects get validated, repository methods get tested. But I've noticed I'm not quite strict enough about the *other* boundaries.

Principles of _modularity_ (e.g., in the 'lego blocks' or 'IKEA furniture' sense of the word's meaning) and _abstraction_ always came more naturally to me, but for whatever reason the principles of _encapsulation_ and _inheritance_ (other pillars of Object-Oriented Programming) and their important boundaries aren't as naturally always black-and-white clear to me without pause and reflection. So I've tried to make that compatible with long-learned software architecture practices.

## Sidebar to my past profession
In the practice of finance, I became allergic to the phrase "best practices", probably because it's something that would be more accurately described as "common practices" at best, and as "foolish things people commonly believe are true" at its worst. The global software engineering community appears to be riddled with similar issues.

So you have to be really discerning: about guidance from others or such "best practices". But discernment is hard earlier on in the exploration of a science: you're a vagabond for an extended period of time, only gradually learning which voices to follow and which to tune out.

And so I, like many of my fellow engineers (and finance practitioners) had/have to experience the pains of bad code myself countless times to truly appreciate why (and where) disciplined boundaries are important. That, and the line between thoughtful rules and pedantic ones always feels hard to get just right.

---

## Some of the mess I (most recently) created

I recently had a renewed sense that I'd shipped too much code too fast with inadequate guardrails, so I decided to revisit the [book Clean Architecture](https://amzn.to/3LryYC9) for a fresh look/reflection... and _oh my god I just realized that the author, Robert Martin, is "Uncle Bob"!_ (the humorous Twitter sensation I've been watching for years, but never put two-and-two together). He has a [great blog](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html), too.

But I couldn't possibly write a comprehensive list of things I've seen or done wrong (and not just because it would be too long, but also because I'm limited by the boundaries of my own present knowledge!).

Instead, here are some current challenges I grappled with, where I'll use some salient examples from my own Java + Spring Boot repo. But most of what I've written here, Java examples aside, are agnostic and repo/framework/language-independent.

```java
// In PeopleV1Controller - boundary violation example
@PutMapping("/detail")
public ResponseEntity<Map<String, Object>> updatePersonDetail(
    @RequestParam(required = false) String id,
    @RequestParam(required = false) String slug,
    @RequestBody Map<String, Object> body) {

    String personId = resolveIdOrThrow(id, slug, s -> personService.resolveIdBySlug(s));
    String normalizedSlug = RequestValidation.normalizeOptionalSlug(body.get("slug"), "slug");
    if (normalizedSlug != null) {
        body.put("slug", normalizedSlug);
    }
    var updated = personService.update(personId, body);
    return ResponseEntity.ok(updated);
}
```

But I really should have put the identifier resolution and slug normalization in a use-case layer, not in the HTTP adapter.

**Potential improvements**
- `resolveIdOrThrow()` â†’ belongs in a `PersonIdentifierResolver` use-case service
- `normalizeOptionalSlug()` â†’ belongs in a `SlugNormalizationService` domain service
- `body.put("slug", ...)` â†’ should happen in the use-case layer, not the controller
- The controller should only translate HTTP â†’ command and return the response

Another one:

```java
// In PersonRepository - web concerns in a data layer
public String create(Map<String, Object> request) {
    String slug = ControllerParameterUtils.normalizeSlugStrict(toStr(request.get("slug")));
    if (slug == null || slug.isBlank()) {
        slug = SlugUtils.slugify(first, last);
    }
    if (slug == null || slug.isBlank()) {
        slug = IdGenerator.generate(8).toLowerCase(Locale.ROOT);
    }
    slug = SlugUtils.ensureUniqueSlug(slug, null, (candidate, ignored) -> existsBySlug(candidate));
    request.put("slug", slug);
    // ... JDBC insert follows
}
```

**Potential improvements**
- `ControllerParameterUtils.normalizeSlugStrict()` â†’ should use a domain `SlugNormalizer` instead
- `SlugUtils.slugify()` â†’ belongs in a `PersonNameSlugGenerator` domain service
- `ensureUniqueSlug()` â†’ belongs in a `UniqueSlugValidator` use-case service
- The repository should only persist validated entities, not generate business rules

Each shortcut created a new dependency direction. But, say, changing the email validation rules requires touching both the controller and the repository, plus every test that had come to depend on this specific behavior.

A few more:

```java
// BaseDomainService.java - 200+ lines of "helpful" abstractions
public abstract class BaseDomainService<T, ID> extends BaseListService {
    protected final String domainName;
    protected final BaseDomainRepository<T, ID> baseRepository;

    // Now includes: caching, circuit breakers, generic CRUD,
    // domain column mappings, string column handling, etc.
    @Cacheable("domain:list")
    @CircuitBreaker(name = "domain-operations")
    public List<T> findPage(FilterParams.Where where, String order, String direction, int limit, int offset) {
        return baseRepository.findPage(where, order, direction, limit, offset);
    }

    // Plus 15 more "convenience" methods...
}
```

The problem shows up when I need to create a `PersonService` that doesn't need caching but does need custom validation. I end up with:

```java
@Service
public class PersonService extends BaseDomainService<PersonDTO, String> {
    // Inherits 200+ lines I don't need
    // But still need to override half the methods
    // And now debugging requires understanding the entire hierarchy
}
```

Or here:

```java
// Controller layer
@PutMapping("/detail")
public ResponseEntity<Map<String, Object>> updatePersonDetail(
    @RequestBody Map<String, Object> body) // Untyped Map

// Service layer - accepts Map
public PersonDTO update(String id, Map<String, Object> request) {
    int rows = personRepository.update(id, request);

// Repository layer - still Map-based
public int update(String id, Map<String, Object> request) {
    if (request.containsKey("nameFirst")) {
        updates.add("name_first = ?");
        args.add(toStr(request.get("nameFirst")));
    }
```

**Potential improvements**
- Controller should accept a typed `UpdatePersonRequest` DTO
- Service should accept a `UpdatePersonCommand` use-case object
- Repository should accept a `Person` domain entity
- All three should share a single validation schema, not three separate Map key interpretations

When I add a new field like `linkedinUrl`, I currently have to update:
1. OpenAPI annotations in the controller
2. Map key handling in the service
3. Column mapping in the repository
4. Frontend expecting specific JSON structure

The cognitive overhead compounds with every change.

---

## So what went wrong, exactly?

The issue isn't that I didn't *know* about clean architecture. The problem was more subtle and familiar: truly grokking the point.

This creates a specific kind of technical debt that's hard to see immediately or objectively, and is unfortunately the most common code found on the web, and is commonly generated by LLMs. The code runs. All tests pass, the API responds correctly... but every change requires understanding multiple layers simultaneously.

And it doesn't scale. Gradually, and then perhaps more suddenly, you hit a wall of maintainability that makes it almost impossible to add or change features.

A new developer can't reason about the system by reading just the controller or just the repository; they need to hold the entire mental model in their head, which I've found is too much to ask a junior developer.

## Rethinking the approach

Instead of treating clean architecture as a destination to reach through heroic refactoring, I try to treat it as a set of guardrails as a crude linting barrier. The goal isn't "perfect layers", but instead "boundaries that are harder to accidentally cross than to respect."

---

### Adding some architectural guardrails

I've added [ArchUnit tests](https://www.archunit.org/userguide/) to catch boundary violations earlier on, similar to how I use [Husky](https://typicode.github.io/husky/) pre-commit and pre-push hooks.

But after a repo is well built out, it feels a bit like rebuilding a house from scratch to prevent an earthquake (I grew up thinking about tornados, and now live a few hundred yards from the San Andreas fault line in California... so it's salient for me ðŸ™ˆ). Sometimes your retrofits need to be more surgical, given the complexities of dealing with a pre-existing structure.

Nonetheless, I still think tools like these are excellent for new repo's and existing repo's alike, and I find them really helpful in all the JavaScript/TypeScript, Java, Python, and Svelte repositories I've worked in so far. Their setup just looks a bit different each time, with lots of finicky quirks for each setup.

### Experimenting with a use-case layer

I'm introducing a thin use-case layer: one class per business action. Not quite services, not quite repositories, but specific orchestrators that coordinate domain logic.

```java
// use-case core (trimmed)
public Person handle(CreatePersonCommand command) {
    if (duplicateCheck.exists(command.email())) {
        throw new DuplicatePersonException(command.email());
    }
    var person = Person.create(command.name(), command.email());
    repository.save(person);
    events.publish(new PersonCreatedEvent(person.id()));
    return person;
}
```

```java
// Inbound Port
public interface CreatePerson {
    Person handle(CreatePersonCommand command);
}
```

### Standardizing the error contract

I'm also gradually replacing ad-hoc error responses with [RFC 9457 Problem Details](https://blog.frankel.ch/problem-details-http-apis/). The goal is making client integration more predictable and not have to mess with them and countless _Sentry_ error regression alerts that are false alarms.

This includes things like mapping constraint violations from [Jakarta Bean Validation](https://beanvalidation.org/). In JavaScript, my favorite is [Zod](https://zod.dev/) for validation and automatic type inference (TypeScript).

In Spring, [ProblemDetail](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ProblemDetail.html) provides a built-in structure for these responses:

```java
@RestControllerAdvice
class ApiExceptionHandler {
    @ExceptionHandler(DuplicatePersonException.class)
    ProblemDetail handleDuplicate(DuplicatePersonException ex) {
        return ProblemDetail.forStatusAndDetail(
            HttpStatus.CONFLICT,
            "Person with email " + ex.email() + " already exists"
        );
    }

}
```

### Trying compile-time mapping with MapStruct

Instead of hand-rolled mappers that seem to drift over time, I've also experimented with [MapStruct](https://mapstruct.org/) to generate type-safe mappings between layers:

```java
public interface PersonWebMapper {
    CreatePersonCommand toCommand(CreatePersonRequest request);
    PersonResponse toResponse(Person person);
}
```

This seems to eliminate a category of bugs where DTOs and domain models get out of sync.

---

## A cleaner repo file tree might look something like this

```markdown
src/ [...]
â”œâ”€â”€ boot/                   # entry + typed config (in this example, for Spring Boot)
â”œâ”€â”€ domain/                 # Business types (minimal framework deps)
â”‚   â”œâ”€â”€ model/              # Value objects and aggregates
â”‚   â”œâ”€â”€ service/            # Domain rules and calculations
â”‚   â””â”€â”€ port/               # Repository interfaces
â”œâ”€â”€ application/            # Use cases (transactional boundaries)
â”‚   â”œâ”€â”€ usecase/            # One class per business action
â”‚   â””â”€â”€ dto/                # Input/output records for use cases
â”œâ”€â”€ adapters/
â”‚   â”œâ”€â”€ in/web/             # HTTP layer (controllers, DTOs, mappers)
â”‚   â””â”€â”€ out/persistence/    # Database layer (repositories, entities)
â””â”€â”€ shared/                 # Cross-cutting utilities
```

---

### Having Clear Boundaries

The right amount of friction appears to prevent the wrong shortcuts without noticeably slowing legitimate development.

On a team, once boundaries are agreed upon and set, they're enforced by tests rather than convention, and then architecture debates happen a lot less often. The code either compiles and finishes the CI/CD pipeline or it doesn't. Discussions are shifting from "where should this logic live?" to "what's the right business rule?"

Velocity should increase meaningfully in my experience after these changes. New features take less time because boundaries are more obvious, error handling is more consistent, and cognitive load is lower.

And that seems like progress: making the codebase work *with* human limitations instead of against them.

---

## Appendix

I started mapping my thoughts and article with these, but as I wrote I decided to move them as supporting material instead of the 'focal point' of the post. But I thought I'd keep them here in case someone else finds them a useful reference:

```markdown
*Runtime Sequence Flow*
HTTP â†’ Controller â†’ (Map) â†’ Inbound Port (Use Case Interface) â†’ Use Case Implementation
     â†’ Domain (Entities/VOs, Services) â†’ Outbound Port (Repository)
     â†’ Repository Implementation (Adapter-Out) â†’ DB/SQL
...and the result flows back the same path, with mappers at the edges.
```

```markdown
*Dependency Flow*
1) Controller â†’ Inbound Port (Use Case Interface) â†’ Use Case Implementation â†’ Domain
2) Use Case â†’ Outbound Port (Repository Interface) â†’ Repository Implementation (Adapter-Out) â†’ DB
3) Web DTOs â†” (MapStruct) â†” App DTOs â†” (MapStruct) â†” Domain
```

## Core Domain Concepts

- **Model**: Core business concept; depends on nothing external. Defines `User` with invariants; never knows HTTP/SQL.
  *Example: `record User(UserId id, Email email) { ... }`*

- **Domain Service**: Pure domain rules that don't fit in aggregates.
  *Example: `class UserValidationService { boolean isValid(Email email) { ... } }`*

## Application Layer

- **Application Service**: Orchestrates business logic and transactions. Takes `CreateUserCommand` â†’ returns `User`; never knows HTTP/storage.
  *Example: `class UserService { User create(CreateUserCommand cmd) { ... } }`*

## Ports

Ports and adapters here follow [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/).

- **Inbound Port (interface)**: Application-defined interface for use cases, e.g., `CreateUser` without implementation details.
  *Example: `interface CreateUser { User handle(CreateUserCommand cmd); }`*

- **Outbound Port (interface)**: Application-defined interface for external capabilities, e.g., `EmailPort.send(email)` without *how*.
  *Example: `interface EmailPort { void send(Email email); }`*

- **Repository (Outbound Port)**: Storage boundary interface in application/domain. Takes `User` â†’ returns `User`:  framework-free and entity-agnostic; never contains business rules.
  *Example: `interface UserRepository { User save(User user); Optional<User> findById(UserId id); }`*

## Adapters and Mappers

- **Adapters**: External boundary. Implements ports (e.g., `EmailPort` using SMTP, or `UserRepository` with mapping to persistence entities), but hides *how* things happen.
  *Example: `class SmtpEmailAdapter implements EmailPort { ... }` or `class JpaUserRepository implements UserRepository { ... /* maps User to Entity */ }`*

- **Mapper**: Shape boundary. Converts `User` â†” `UserDto`; shape-only transform (no business logic).
  *Example: `@Mapper interface UserMapper { UserDto toDto(User user); }`*

## Web/HTTP Components

- **Controller**: HTTP boundary. Takes `POST /users {"name":"Alice"}` â†’ produces `CreateUserCommand`; returns HTTP response: never decides *how* to create users.
  *Example: `@PostMapping ResponseEntity<UserResponse> create(@RequestBody CreateUserRequest req)`*

- **Global Exception Handler**: Cross-boundary. Converts exceptions â†’ HTTP status codes: never changes *what* went wrong. In Spring, implemented via Advice; document standardized error responses in OpenAPI specifications for better API client integration and consistency.
  *Example: `@RestControllerAdvice class GlobalExceptionHandler { ... }`*

- **Filter**: Pipeline boundary. Converts HTTP requests â†’ authenticated requests: never changes *what* the request asks for.
  *Example: `class AuthFilter extends OncePerRequestFilter { ... }`*

Lastly, a few more code examples...

**Repository depending on web services:**
```java
// EntityRepository.java - data layer depending on web layer
@Repository
public class EntityRepository extends BaseDomainRepository<EntityDTO, String> {
    private final WebUrlService webUrlService;  // Web-facing service

    public Map<String, Object> findWebUrlsByEntityId(String entityId) {
        return webUrlService.findWebUrlsByEntityId(entityId);  // Wrong direction
    }
}
```

**Service layer handling HTTP concerns:**
```java
// UserService.java - service layer with HTTP dependencies
public void writeSessionCookie(
    HttpServletRequest request,
    HttpServletResponse response,
    Jwt jwt,
    String accessToken) {
    // Service now knows about cookies, domains, SameSite policies
    ResponseCookie cookie = ResponseCookie.from("session", accessToken)
        .httpOnly(true)
        .secure(request.isSecure())
        .build();
    response.addHeader(HttpHeaders.SET_COOKIE, cookie.toString());
}
```
