/**
 * Books S3 Data Access (Server-only)
 * @module lib/books/books-data-access.server
 * @description
 * Reads consolidated book data from S3 (generated by scripts/generate-books.ts).
 * Provides the same public API as audiobookshelf.server.ts so consumer code only
 * changes its import path, not its function calls.
 *
 * Caching: In-memory cache with 1-hour TTL + Next.js Cache Components ("use cache").
 *
 * Error contract: S3 connectivity errors surface via `isFallback: true` in the
 * public API return values. Callers can distinguish "successfully loaded books"
 * from "returning stale/empty data due to infrastructure failure."
 */

import "server-only";

import { readJsonS3Optional } from "@/lib/s3/json";
import { BOOKS_S3_PATHS } from "@/lib/constants";
import { envLogger } from "@/lib/utils/env-logger";
import { getMonotonicTime } from "@/lib/utils";
import { cacheContextGuards } from "@/lib/cache";
import {
  booksDatasetSchema,
  booksLatestSchema,
  type Book,
  type BookListItem,
  type BooksDataset,
} from "@/types/schemas/book";

// ─────────────────────────────────────────────────────────────────────────────
// In-Memory Cache
// ─────────────────────────────────────────────────────────────────────────────

const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour
const CACHE_RETRY_TTL_MS = 5 * 60 * 1000; // 5 minutes — shorter retry window after S3 failure

/**
 * `lastRefreshFailed` tracks whether the most recent S3 load attempt failed.
 * When true, public API returns `isFallback: true` so callers know the data
 * may be stale or empty due to infrastructure issues — not because zero books exist.
 */
let cache: { books: Book[]; timestamp: number; lastRefreshFailed: boolean } | null = null;

function isCacheFresh(): boolean {
  if (!cache) return false;
  if (cache.timestamp === 0) return true; // prerender-safe
  const ttl = cache.lastRefreshFailed ? CACHE_RETRY_TTL_MS : CACHE_TTL_MS;
  return getMonotonicTime() - cache.timestamp <= ttl;
}

// ─────────────────────────────────────────────────────────────────────────────
// S3 Loader
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Load the consolidated books dataset from S3.
 * Reads latest.json pointer, then fetches the versioned snapshot.
 *
 * Returns `null` when the dataset has not been generated yet (expected
 * on first deploy). Throws on real S3 connectivity/permission errors
 * so callers can distinguish "no data" from "infrastructure failure".
 */
async function loadBooksFromS3(): Promise<Book[] | null> {
  const latest = await readJsonS3Optional(BOOKS_S3_PATHS.LATEST, booksLatestSchema);
  if (!latest) {
    envLogger.log(
      "No books latest.json found in S3 — dataset may not have been generated yet",
      { path: BOOKS_S3_PATHS.LATEST },
      { category: "Books" },
    );
    return null;
  }

  const dataset = await readJsonS3Optional<BooksDataset>(latest.key, booksDatasetSchema);
  if (!dataset) {
    envLogger.log(
      "Books versioned snapshot not found in S3",
      { key: latest.key, checksum: latest.checksum },
      { category: "Books" },
    );
    return null;
  }

  return dataset.books;
}

// ─────────────────────────────────────────────────────────────────────────────
// Cache Management (Command — mutates state, returns nothing)
// ─────────────────────────────────────────────────────────────────────────────

let inflightRefresh: Promise<void> | null = null;

/**
 * Command: refresh the in-memory cache from S3.
 * Coalesces concurrent refreshes via a shared promise.
 *
 * On success: updates cache with fresh data, clears failure flag.
 * On S3 error: logs the error and sets `lastRefreshFailed = true` so the
 * public API can report `isFallback: true`. Cache retains previous books
 * (if any) to serve stale data rather than empty.
 */
async function refreshCache(): Promise<void> {
  if (inflightRefresh) {
    return inflightRefresh;
  }

  inflightRefresh = (async () => {
    try {
      const books = await loadBooksFromS3();
      cache = { books: books ?? [], timestamp: getMonotonicTime(), lastRefreshFailed: false };
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      envLogger.log("Failed to load books from S3", { error: message }, { category: "Books" });

      // Preserve stale data if available; mark failure so callers see isFallback: true
      if (cache) {
        cache = { ...cache, timestamp: getMonotonicTime(), lastRefreshFailed: true };
      } else {
        cache = { books: [], timestamp: getMonotonicTime(), lastRefreshFailed: true };
      }
    }
  })().finally(() => {
    inflightRefresh = null;
  });

  return inflightRefresh;
}

// ─────────────────────────────────────────────────────────────────────────────
// Cache Read (Query — reads state, does not mutate)
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Query: return the current cached books and failure state, refreshing first if stale.
 */
async function getCachedBooksState(): Promise<{ books: Book[]; isFallback: boolean }> {
  if (!isCacheFresh()) {
    await refreshCache();
  }
  return {
    books: cache?.books ?? [],
    isFallback: cache?.lastRefreshFailed ?? false,
  };
}

// ─────────────────────────────────────────────────────────────────────────────
// Cached Internal Implementation
// ─────────────────────────────────────────────────────────────────────────────

async function fetchBooksInternal(): Promise<{ books: Book[]; isFallback: boolean }> {
  "use cache";

  cacheContextGuards.cacheLife("Books", { revalidate: 3600 }); // 1 hour
  cacheContextGuards.cacheTag("Books", "books-dataset");

  return getCachedBooksState();
}

// ─────────────────────────────────────────────────────────────────────────────
// Public API — same signatures as audiobookshelf.server.ts
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Fetch all books. Reports `isFallback: true` when S3 load failed and data
 * is stale or empty.
 */
export async function fetchBooksWithFallback(
  _options?: Record<string, unknown>,
): Promise<{ books: Book[]; isFallback: boolean; fetchedAt: number }> {
  const { books, isFallback } = await fetchBooksInternal();
  return { books, isFallback, fetchedAt: 0 };
}

/**
 * Fetch all books (simple wrapper).
 * Used by sitemap.ts and other consumers that don't need fallback metadata.
 * Logs a warning when returning stale/fallback data so callers are aware.
 */
export async function fetchBooks(): Promise<Book[]> {
  const { books, isFallback } = await fetchBooksInternal();
  if (isFallback) {
    envLogger.log(
      "fetchBooks() returning stale/fallback data due to S3 failure",
      { bookCount: books.length },
      { category: "Books" },
    );
  }
  return books;
}

/**
 * Fetch a single book by ID. Reports `isFallback: true` when S3 load failed.
 */
export async function fetchBookByIdWithFallback(
  id: string,
  _options?: Record<string, unknown>,
): Promise<{ book: Book | null; isFallback: boolean }> {
  const { books, isFallback } = await fetchBooksInternal();
  const book = books.find((b) => b.id === id) ?? null;
  return { book, isFallback };
}

/**
 * Fetch minimal book list items. Reports `isFallback: true` when S3 load failed.
 */
export async function fetchBookListItemsWithFallback(
  _options?: Record<string, unknown>,
): Promise<{ books: BookListItem[]; isFallback: boolean; fetchedAt: number }> {
  const { books, isFallback } = await fetchBooksInternal();
  const items: BookListItem[] = books.map(({ id, title, authors, coverUrl, coverBlurDataURL }) => ({
    id,
    title,
    authors,
    coverUrl,
    coverBlurDataURL,
  }));
  return { books: items, isFallback, fetchedAt: 0 };
}

/**
 * Clear in-memory books cache. Exposed for testing.
 */
export function clearBooksCache(): void {
  cache = null;
  inflightRefresh = null;
}
